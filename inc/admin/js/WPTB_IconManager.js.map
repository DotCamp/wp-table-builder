{"version":3,"sources":["WPTB_IconManager.js"],"names":["key","context","factory","self","global","wptb_admin_object","list","Error","iconList","cachedIcons","prepareIcon","iconSvgString","extraClass","arguments","length","undefined","stringifiedVersion","iconWrapper","document","createElement","Array","isArray","map","eClass","classList","add","innerHTML","outerHTML","getIconList","getIcon","iconName","getStringifiedVersion","Promise","res","rej","cachedIcon","getCachedIcon","fetch","then","resp","ok","text","concat","iconString","error","stringifiedIcon","addToCache","catch","err","getIconUrl","iconUrl","iconManager"],"mappings":";;AA4JE,IAAA,EAAA,UAAA,IArJF,SAAyBA,EAAKC,EAASC,GAEtCD,EAAQD,GAAOE,IAFhB,CAIG,mBAAoBC,MAAQC,EAAQ,WA4ItC,OADgBD,MAAQC,GACZC,kBACJ,IAtIR,SAAqBC,GACpB,IAAKA,EACJ,MAAM,IAAIC,MAAM,yDAEjB,IAAMC,EAAWF,EAOXG,EAAc,GAUdC,EAAc,SAACC,GAAiE,IAAlDC,EAAUC,UAAAC,OAAAD,QAAAE,IAAAF,UAAAE,GAAAF,UAAG,GAAA,KAAMG,EAAkBH,UAAAC,OAAAD,QAAAE,IAAAF,UAAAE,IAAAF,UAAG,GACrEI,EAAcC,SAASC,cAAc,OAiB3C,OAdIP,IACEQ,MAAMC,QAAQT,KAElBA,EAAa,CAACA,IAIfA,EAAWU,IAAI,SAACC,GACfN,EAAYO,UAAUC,IAAIF,MAI5BN,EAAYS,UAAYf,EAEjBK,EAAqBC,EAAYU,UAAYV,GAiCrD,KAAKW,YAAc,WAClB,OAAOpB,GAaR,KAAKqB,QAAU,SAACC,GAA+D,IAArDlB,EAAUC,UAAAC,OAAAD,QAAAE,IAAAF,UAAAE,GAAAF,UAAG,GAAA,KAAMkB,EAAqBlB,UAAAC,OAAAD,QAAAE,IAAAF,UAAAE,IAAAF,UAAG,GAEpE,OAAO,IAAImB,QAAQ,SAACC,EAAKC,GAExB,IAAMC,EAxCc,SAACL,GAA+D,IAArDlB,EAAUC,UAAAC,OAAAD,QAAAE,IAAAF,UAAAE,GAAAF,UAAG,GAAA,KAAMkB,EAAqBlB,UAAAC,OAAAD,QAAAE,IAAAF,UAAAE,IAAAF,UAAG,GAC3E,OAAIJ,EAAYqB,GACRpB,EAAYD,EAAYqB,GAAWlB,EAAYmB,GAEhD,KAoCaK,CAAcN,EAAUlB,EAAYmB,GACvD,OAAII,EACIF,EAAIE,GAGR3B,EAASsB,GACLO,MAAM7B,EAASsB,IACpBQ,KAAK,SAACC,GACN,GAAIA,EAAKC,GACR,OAAOD,EAAKE,OAEb,MAAM,IAAIlC,MAAKmC,0CAAAA,OAA2CZ,EAAW,QAErEQ,KAAK,SAACK,GACN,GAAIA,EAAWC,MACd,MAAM,IAAIrC,MAAKmC,0CAAAA,OAA2CZ,EAAW,MAMtE,OAhDc,SAACA,EAAUe,GAC7BpC,EAAYqB,GAAYe,EA6CpBC,CAAWhB,EAAUa,GAEdV,EAAIvB,EAAYiC,EAAY/B,EAAYmB,MAE/CgB,MAAM,SAACC,GACP,OAAOd,EAAI,IAAI3B,MAAMyC,MAGjBd,EAAI,IAAI3B,MAAKmC,yCAAAA,OAA0CZ,EAAW,UAG3E,KAAKmB,WAAa,SAACnB,GAClB,IAAIoB,EAAU,KAMd,OAJI1C,EAASsB,KACZoB,EAAU1C,EAASsB,IAGboB,GAOD,CAAgB7C,kBAAkB8C,aAGnC","file":"WPTB_IconManager.js","sourceRoot":"core\\rollup-source","sourcesContent":["/**\n * Assign icon manager to global space.\n *\n * @param {string} key global key\n * @param {Object} context global context\n * @param {Function} factory factory function\n */\n(function assignToGlobal(key, context, factory) {\n\t// eslint-disable-next-line no-param-reassign\n\tcontext[key] = factory();\n\t// eslint-disable-next-line no-restricted-globals\n})('WPTB_IconManager', self || global, function iconManager() {\n\t/**\n\t * Frontend icon manager for WPTB builder.\n\t *\n\t * @param {Object} list all icon list\n\t * @class\n\t */\n\tfunction IconManager(list) {\n\t\tif (!list) {\n\t\t\tthrow new Error('no icon list is defined for WPTB_IconManager instance');\n\t\t}\n\t\tconst iconList = list;\n\n\t\t/**\n\t\t * Cached icons.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tconst cachedIcons = {};\n\n\t\t/**\n\t\t * Prepare an icon with a wrapper.\n\t\t *\n\t\t * @param {string} iconSvgString string representation of icon\n\t\t * @param {Array | string | null} extraClass name of extra class[es] to apply to icon wrapper\n\t\t * @param {boolean} stringifiedVersion get stringified html version of icon\n\t\t * @return {HTMLDivElement} created icon wrapper\n\t\t */\n\t\tconst prepareIcon = (iconSvgString, extraClass = null, stringifiedVersion = false) => {\n\t\t\tconst iconWrapper = document.createElement('div');\n\n\t\t\t// if an extra class is defined, add it to icon wrapper\n\t\t\tif (extraClass) {\n\t\t\t\tif (!Array.isArray(extraClass)) {\n\t\t\t\t\t// eslint-disable-next-line no-param-reassign\n\t\t\t\t\textraClass = [extraClass];\n\t\t\t\t}\n\n\t\t\t\t// eslint-disable-next-line array-callback-return\n\t\t\t\textraClass.map((eClass) => {\n\t\t\t\t\ticonWrapper.classList.add(eClass);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\ticonWrapper.innerHTML = iconSvgString;\n\n\t\t\treturn stringifiedVersion ? iconWrapper.outerHTML : iconWrapper;\n\t\t};\n\n\t\t/**\n\t\t * Get a cached icon.\n\t\t *\n\t\t * @param {string} iconName name of the icon\n\t\t * @param {string | Array | null} extraClass extra class name[s] to add to icon wrapper\n\t\t * @param {boolean | null} getStringifiedVersion get stringified version of the icon\n\t\t * @return {null | Element} Prepared cached icon or null if no cached version is found\n\t\t */\n\t\tconst getCachedIcon = (iconName, extraClass = null, getStringifiedVersion = false) => {\n\t\t\tif (cachedIcons[iconName]) {\n\t\t\t\treturn prepareIcon(cachedIcons[iconName], extraClass, getStringifiedVersion);\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\n\t\t/**\n\t\t * Add an icon to cache.\n\t\t *\n\t\t * @param {string} iconName name of the icon to be stored\n\t\t * @param {string} stringifiedIcon stringified version of the icon\n\t\t */\n\t\tconst addToCache = (iconName, stringifiedIcon) => {\n\t\t\tcachedIcons[iconName] = stringifiedIcon;\n\t\t};\n\n\t\t/**\n\t\t * Get a list of all available icons.\n\t\t *\n\t\t * @return {Object} icon list\n\t\t */\n\t\tthis.getIconList = () => {\n\t\t\treturn iconList;\n\t\t};\n\n\t\t/**\n\t\t * Get an icon.\n\t\t *\n\t\t * Icons sent with this function are wrapped with a 'div' element.\n\t\t *\n\t\t * @param {string} iconName name of the icon\n\t\t * @param {string | Array | null} extraClass extra class[es] to add to icon wrapper\n\t\t * @param {boolean} getStringifiedVersion get stringified version of icon\n\t\t * @return {Promise<void>} a Promise that will be resolved when icon is fetched from server\n\t\t */\n\t\tthis.getIcon = (iconName, extraClass = null, getStringifiedVersion = false) => {\n\t\t\t// eslint-disable-next-line consistent-return\n\t\t\treturn new Promise((res, rej) => {\n\t\t\t\t// if cached version is found, return that version\n\t\t\t\tconst cachedIcon = getCachedIcon(iconName, extraClass, getStringifiedVersion);\n\t\t\t\tif (cachedIcon) {\n\t\t\t\t\treturn res(cachedIcon);\n\t\t\t\t}\n\n\t\t\t\tif (iconList[iconName]) {\n\t\t\t\t\treturn fetch(iconList[iconName])\n\t\t\t\t\t\t.then((resp) => {\n\t\t\t\t\t\t\tif (resp.ok) {\n\t\t\t\t\t\t\t\treturn resp.text();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthrow new Error(`an error occurred while fetching icon [${iconName}]`);\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then((iconString) => {\n\t\t\t\t\t\t\tif (iconString.error) {\n\t\t\t\t\t\t\t\tthrow new Error(`an error occurred while fetching icon [${iconName}]`);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// add icon to cache\n\t\t\t\t\t\t\taddToCache(iconName, iconString);\n\n\t\t\t\t\t\t\treturn res(prepareIcon(iconString, extraClass, getStringifiedVersion));\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch((err) => {\n\t\t\t\t\t\t\treturn rej(new Error(err));\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn rej(new Error(`no icon found with the given name of [${iconName}]`));\n\t\t\t});\n\t\t};\n\t\tthis.getIconUrl = (iconName) => {\n\t\t\tlet iconUrl = null;\n\n\t\t\tif (iconList[iconName]) {\n\t\t\t\ticonUrl = iconList[iconName];\n\t\t\t}\n\n\t\t\treturn iconUrl;\n\t\t};\n\t}\n\n\t// eslint-disable-next-line no-restricted-globals\n\tconst context = self || global;\n\tif (context.wptb_admin_object) {\n\t\treturn new IconManager(wptb_admin_object.iconManager);\n\t}\n\n\treturn null;\n});\n"]}